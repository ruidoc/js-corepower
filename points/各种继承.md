## 继承

这里说说常见的几种继承。

### 1. 原型继承

```js
let Super = functioin(name = 'eric') {
    this.name = name;
    this.getName = function() {
        return this.name;
    }
}

let Sub = function(sex = 'male') {
    this.sex = sex;
}
Sub.prototype = new Super('eric');  //通过改变原型对象实现继承
Sub.prototype.constructor = Sub // 保持构造函数和原型对象的完整性
```

优点：父类的方法(getName)得到了复用。
缺点：父类的属性(name)也是复用，即子类实例没有自己的属性。

### 2. 构造函数继承

```js
let Super = function (name = "eric") {
  this.name = name;
  this.getName = function () {
    return this.name;
  };
};
let Sub = function (name, sex) {
  Super.call(this, name);
  this.sex = sex;
};
```

优点：子类的每个实例都有自己的属性。
缺点：但是继承父类方法的时候就不需要这种特性，没有实现父类方法的复用。

### 3. 组合式继承

```js
let Super = function (name = "eric") {
  this.name = name;
};
Super.prototype = {
  constructor: Super,
  getName() {
    return this.name;
  },
};
let Sub = function (sex) {
  Super.call(this, "eric"); //继承父类属性
  this.sex = sex;
};
Sub.prototype = new Super("eric"); //继承父类方法
Sub.prototype.constructor = Sub;
```

优点：继承了上述两种方式的优点，摒弃了缺点，复用了方法，子类又有各自的属性。
缺点：父类属性被覆盖掉

### 4. es6 中的 class

```js
class Super() {
    constructor(props = { name: 'eric' }) {
        this.name = props.name;
    }
    setName(name) {
        this.name = name;
    }
    getName() {
        return this.name;
    }
}
class Sub extends Super {
    constructor(props) {
        super(props = { sex: 'male' }); // 创建实例，继承父类属性和方法
        this.sex = props.sex;
    }
}
```
