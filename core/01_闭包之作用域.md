## 闭包的方向

闭包背后反映出来的，是 `作用域`、`作用域链` 的问题。

### 作用域

核心：存储和访问变量的一套规则。

变量声明是在一个作用域内，变量访问也是在一个作用域内

### 编译原理

一个简单的声明语句：

```javascript 
var name = 'xiuyan'
```

在 JS 引擎眼里，它却包含了两个声明：

```javascript 
var name; //（编译时处理）
name = "xiuyan"; //（运行时处理）
```

此处的编译时处理和运行时处理，分别对应编译阶段和执行阶段，下面详细解释：

#### 编译阶段

主角：`编译器`登场！

* 查看当前作用域是否有 `name`变量
* 如果有，忽略当前变量声明
* 如果没有，在当前作用域里新增一个 name

#### 执行阶段

主角：`JS引擎`登场！

* 查看当前作用域是否有 `name`变量
* 如果有，进行赋值
* 如果没有，递归查找父作用域
* 如果全局也没有，就在全局作用域创建该变量

### 作用域链

es5只有 `全局作用域`和 `函数作用域`，
新语法又增加了 `块作用域`和 `模块作用域`

#### 全局作用域

全局变量：声明在任何函数之外的顶层作用域的变量。全局变量拥有全局作用域

#### 函数作用域

在函数内部定义的变量，拥有函数作用域

```javascript
function sayHello() {
  // hello 被定义成局部作用域变量
  var hello = 'hello everyone';
  console.log(hello);
}
console.log(hello); // 抛出错误：hello 在全局作用域未定义
```

#### 块级作用域

* 必须用块写法
* 必须是`let`或者`const`声明

```
{
  let a = 1;
  console(a);
}
```

#### 模块作用域

在nodejs中，任何独立的脚本文件中声明的变量都相互独立，互不污染

### 闭包概念

先来看一个例子：

```javascript
function addABC(){
  var a = 1,b = 2;
  
  function add(){
    return a+b+c;
  }
  return add;
}

var c = 3

var globalAdd = addABC()

console.log(globalAdd()) // 6
```

像 a、b、c 这样`在函数中被使用`，但它既不是`函数参数`、也不是`函数的局部变量`，叫做`自由变量`。而像 add 这样引用了自由变量的`函数`，就叫闭包。

不过我们通常理解的闭包，是**引用了其他函数作用域的变量的函数**，即“函数内部的函数“，不包括全局作用域下的函数。
