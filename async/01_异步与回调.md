## 概念

JS 异步解决方案，始终是面试中的热点与重点。

考察核心：对 JS 异步 以及异步解决方案，到底理解到什么程度

### 生活中的同步与异步

比如你去KFC排队买炸鸡，点餐付款需要一分钟，出餐需要十分钟。如果你点餐后等到出餐才离开，后面的人不知道要排到什么时候了

上面的情况，就是”同步“。即一个人的任务全部完成，再进行下一个人的任务。这样明显会大大的浪费时间。

另一种方案：收银台花一分钟点餐付款，然后拿到小票回到座位等着取餐，后面的人继续点。出餐前的九分钟你可以做任何事，等到叫号时去取餐，任务就完成了。这就是”异步“

### JS 中的同步与异步

JS 的 **任务执行模式** 分为同步和异步。

同步，就是说后一个任务必须等待前一个任务全部执行完毕再执行，任务的执行顺序和排列顺序高度一致

异步，则恰恰相反，任务的执行顺序不必遵循排列顺序，效率和利用率优先

## 异步进化史

异步方案的四个进化阶段：

**回调函数 —> Promise —> Generator —> async/await。**

### 回调函数

Promise 出现前的一个相对早期的阶段，是异步最常见、最基本的实现手段

除此之外，事件监听、发布订阅等方式，也经常为我们所用

#### 事件监听

上一个大家最熟悉的例子：

```javascript
document.getElementById('#myDiv').addEventListener('click', function (e) {
  console.log('我被点击了')
}, false);
```

这就是一个典型的事件监听，把任务的执行时机推迟到了点击这个动作发生时

#### 发布订阅

看一下 jquery 的发布订阅，更能直观的理解：

```javascript
function consoleTrigger() {
    console.log('trigger事件被触发')
}
// 订阅
jQuery.subscribe('trigger',consoleTrigger);
// 发布
jQuery.publish('trigger');
```

大家会发现这种模式和事件监听下的异步处理非常相似

#### 回调函数

回调函数用的最多的地方其实是在 Node 环境下，如网络请求，文件读写，都是异步的

```javascript
// -- 异步读取文件
fs.readFile(filePath,'utf8',function(err,data){
    if(err) {
      throw err;
    }
    console.log(data);// 输出文件内容
});
```

#### “回调地狱”

一层回调感觉没什么问题，可回调多了之后，代码的**可读性**和**可维护性**将面临严峻的挑战

```javascript
const https = require('https');


https.get('目标接口1', (res) => {
  console.log(data)
  https.get('目标接口2', (res) => {
    https.get('目标接口3'),  (res) => {
        console.log(data)
        https.get('目标接口4', (res) => {
          https.get('目标接口5', (res) => {
            console.log(data)
            .....
            // 无尽的回调
          }
        }
    }
  }
})
```